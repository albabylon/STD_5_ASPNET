«Из коробки» в ASP.Net Core Web API предусмотрена некоторая валидация данных, то есть, если пользователь будет явно ошибаться в формате, запрос не пройдет

Если мы передаем неверный формат данных, который не может быть преобразован в число, поэтому получаем в ответе код 400 Bad Request
Можем просто забыть передать некоторые свойства, и запрос всё равно пройдет

_______
К примеру, попытаемся сохранить устройство с рабочим напряжением в 12 вольт, в то время как наша электросеть поддерживает 127-220 вольт, 
и такое устройство подключать нельзя. Что же можно сделать, чтобы этого не произошло?

_______
1 Вручную

Сделать проверку в контроллере, и возвращать клиенту информативный код ошибки:

if (request.CurrentVolts < 120)
{
	return StatusCode(403, $"Устройства с напряжением меньше 120 вольт не поддерживаются!");
}

_______
2 Атрибуты

Атрибуты позволяют нам прописать правила валидации модели прямо в ней, 
и даже указать приложению, какую ошибку показывать, если эти правила нарушены.

[Required] 
[Range(120, 220, ErrorMessage = "Поддерживаются устройства с напряжением от {1} до {2} вольт")]



Кстати, если у вас уже есть валидация на атрибутах, но для какого-либо из свойств вы дополнительно хотите добавить ручную валидацию 
— правильным будет возвращать текст с ошибками в том же формате, в каком он возвращается при валидации на атрибутах
Сделать это можно, используя объект ModelState.

_______
3 ModelState

ModelState.AddModelError("currentVolts", "Устройства с напряжением меньше 120 вольт не поддерживаются!");
return BadRequest(ModelState);

_______
4 FluentValidation

Суть подхода, который она предлагает, состоит в том, 
чтобы делегировать валидацию отдельному классу-валидатору, который создается под каждую модель.

Логика валидации убирается из основного кода контроллеров и моделей и более не мешает при разработке.
Однако общее количество классов у нас всё-таки прибавится